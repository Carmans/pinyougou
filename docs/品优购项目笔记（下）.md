## 品优购项目笔记（下）

[TOC]

### 购物车解决方案

用户在商品详细页点击加入购物车，提交商品 SKU 编号和购买数量，添加到购物车。当用户在未登录的情况下，将此购物车存入 cookies , 在用户登陆的情况下，将购物车数据存入 redis 。如果用户登陆时，cookies 中存在购物车，需要将 cookies 的购物车合并到 redis 中存储.

购物车数据存储结构：![购物车数据存储结构](https://hexoblog-1253306922.cos.ap-guangzhou.myqcloud.com/photo2018/%E5%93%81%E4%BC%98%E8%B4%AD/%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%88%97%E8%A1%A8%E6%A8%A1%E5%9E%8B.png)



购物车实体类：

```java
public class Cart implements Serializable{	// 对每一个商家购物车的封装
	private String sellerId;	// 商家ID
	private String sellerName;	// 商家名称
	private List<TbOrderItem> orderItemList;	// 购物车明细
 	// setter getter方法   
}
```



**Cookie 存储购物车**

​	

服务实现层：向购物车列表中添加物品

```java
@Override
public List<Cart> addGoodsToCartList(List<Cart> cartList, Long itemId, Integer num) {

    // 1. 根据skuID （itemId）查询商品明细sku的对象
    TbItem item = itemMapper.selectByPrimaryKey(itemId);
    if (item == null) throw new RuntimeException("商品不存在");
    // 时间差，比如在添加提交订单时，商品下架了
    if (!"1".equals(item.getStatus())) throw new RuntimeException("商品不存在");

    // 2. 根据sku对象获取商家ID
    String sellerId = item.getSellerId();

    // 3. 根据商家ID在购物车列表中查询购物车对象
    Cart cart = searchCartBySellerId(cartList, sellerId);

    // 4.如果购物车列表中不存在该商家ID对应的购物车对象
    if (cart == null) {
        // 4.1创建该商家的购物车对象
        cart = new Cart();
        cart.setSellerId(sellerId);
        cart.setSellerName(item.getSeller());

        // 创建购物车明细对象
        List<TbOrderItem> orderItemList = new ArrayList<>();
        TbOrderItem orderItem = createOrderItem(item, num);
        orderItemList.add(orderItem);

        cart.setOrderItemList(orderItemList);
        // 4.2将该购物车对象添加到购物车列表中
        cartList.add(cart);
    }else {	 // 5. 如果购物车列表中存在该商家ID对应的购物车对象
        // 然后判断购物车对象中是否存在该商品的明细对象
        TbOrderItem orderItem = searchOrderItemByItemId(cart.getOrderItemList(), itemId);
        if (orderItem == null) { 	// 5.1 如果明细列表中不存在，创建明细对象添加到购物车对象中
            // 创建购物车明细对象
            orderItem = createOrderItem(item, num);
            cart.getOrderItemList().add(orderItem);	
        }else {		// 5.2 如果明细列表中存在，则增加对应的数量
            orderItem.setNum(orderItem.getNum()+num);	// 更改数量
            orderItem.setTotalFee( new BigDecimal(orderItem.getPrice().doubleValue()*orderItem.getNum()) );	// 更改价格
            if(orderItem.getNum()<1) cart.getOrderItemList().remove(orderItem);	// 当明细的数量小于1时移除
            if (cart.getOrderItemList().size()<1) cartList.remove(cart);		// 当购物车的明细项数为0时，移除购物车列表该对象
        }
    }

    return cartList;
}
/**
 * 根据商家ID在购物车列表中查询该商家的购物车
 * @param cartList
 * @param sellerId
 * @return
 */
private Cart searchCartBySellerId(List<Cart> cartList, String sellerId) {
	for(Cart cart :cartList) {
		if (sellerId.equals(cart.getSellerId())) {
			return cart;
		}
	}
	return null;
}

// 创建新的购物明细对象
private TbOrderItem createOrderItem(TbItem item, Integer num) {
	if(num<1) throw new RuntimeException("非法数量");
	TbOrderItem order = new TbOrderItem();
	order.setGoodsId(item.getGoodsId());
	order.setItemId(item.getId());
	order.setNum(num);
	order.setPicPath(item.getImage());
	order.setPrice(item.getPrice());
	order.setSellerId(item.getSellerId());
	order.setTitle(item.getTitle());
	order.setTotalFee(new BigDecimal( item.getPrice().doubleValue()*num ));
	return order;
}

/**
 * 在购物车明细列表中，根据SKUID查询购物车明细对象
 * @param orderItemList
 * @param itemId
 * @return
 */
private TbOrderItem searchOrderItemByItemId(List<TbOrderItem> orderItemList, Long itemId) {
	for(TbOrderItem orderItem : orderItemList) {
		if (orderItem.getItemId().longValue()==itemId.longValue()) {
			return orderItem;
		}
	}
	return null;
}
```



控制层：

```java
/**
 * 购物车列表
 * 
 * @param request
 * @return
 */
@RequestMapping("/findCartList")
public List<Cart> findCartList() {
	String cartListString = util.CookieUtil.getCookieValue(request, "cartList", "UTF-8");
	if (cartListString == null || cartListString.equals("")) {
		cartListString = "[]";
	}
	List<Cart> cartList_cookie = JSON.parseArray(cartListString, Cart.class);
	return cartList_cookie;
}

/**
 * 添加商品到购物车
 * 
 * @param request
 * @param response
 * @param itemId
 * @param num
 * @return
 */
@RequestMapping("/addGoodsToCartList")
public Result addGoodsToCartList(Long itemId, Integer num) {
	try {
		List<Cart> cartList = findCartList();// 获取购物车列表
		cartList = cartService.addGoodsToCartList(cartList, itemId, num);
		util.CookieUtil.setCookie(request, response, "cartList", JSON.toJSONString(cartList), 3600 * 24, "UTF-8");
		return new Result(true, "添加成功");
	} catch (Exception e) {
		e.printStackTrace();
		return new Result(false, "添加失败");
	}
}
```



前端服务层：将逻辑实现放在服务层，以便重用。

```javascript
// 购物车明细求和
this.sum=function(cartList){
	var total = {totalNum:0, totalMoney:0};

	for(var i=0;i<cartList.length;i++){
		var cart = cartList[i];
		for(var j=0;j<cart.orderItemList.length;j++){
			var item=cart.orderItemList[j];		// 购物车明细
			total.totalNum +=item.num;
			total.totalMoney += item.totalFee;
		}
	}
	return total;
}
```



**Redis 存储购物车**

判断当前用户是否登陆，如果未登录采用 Cookie 存储，如果登录则采用 Redis 存储。登录后要进行 Cookie 购物车与 Redis 购物车的合并操作，并清除 Cookie 购物车。

1. 首先修改 spring-security 配置文件

```xml
<!-- <http pattern="/cart/*.do" security="none"></http> -->	<!-- 这种方式会导致不会经过登录认证操作，无法获取登录用户名 -->

<!--   entry-point-ref  入口点引用 -->
<http use-expressions="false" entry-point-ref="casProcessingFilterEntryPoint">  
	<intercept-url pattern="/cart/*.do" access="IS_AUTHENTICATED_ANONYMOUSLY"/>
    <intercept-url pattern="/**" access="ROLE_USER"/>   
    <csrf disabled="true"/>  
    <!-- custom-filter为过滤器， position 表示将过滤器放在指定的位置上，before表示放在指定位置之前  ，after表示放在指定的位置之后  -->           
    <custom-filter ref="casAuthenticationFilter"  position="CAS_FILTER" />      
    <custom-filter ref="requestSingleLogoutFilter" before="LOGOUT_FILTER"/>  
    <custom-filter ref="singleLogoutFilter" before="CAS_FILTER"/>  
</http>
```

之前配置的过滤购物车拦截的方式，会导致该逻辑不会经过spring security的生命周期。那么在 CartController 中就无法通过 `SecurityContextHolder.getContext().getAuthentication().getName()` 的方式来获取当前登录用户名。报空指针异常。

access="IS_AUTHENTICATED_ANONYMOUSLY" 用于设置资源可以在不登陆时可以访问。此 配 置 与 security="none" 的 区 别 在 于 当 用 户 未 登 陆 时 获 取 登 陆 人 账 号 的 值 为 anonymousUser ，而 security="none"的话，无论是否登陆都不能获取登录人账号的值。

1. 服务层实现

```java
@Override
public List<Cart> findCartListFromRedis(String username) {
    // System.out.println("从redis中获取购物车数据");
    List<Cart> cartList = (List<Cart>) redisTemplate.boundHashOps("cartList").get(username);
    if(cartList == null) cartList = new ArrayList<>();
    return cartList;
}

@Override
public void addCartListToRedis(String username, List<Cart> cartList) {
    // System.out.println("向Redis中存储购物车数据");
    redisTemplate.boundHashOps("cartList").put(username, cartList);
}
```

1. 控制层实现，通过判断用户是否登录来选择从cookie还是redis中读取数据

```java
@RequestMapping("/findCartList")
public List<Cart> findCartList() {
    // 获取当前登录用户名
    String username = SecurityContextHolder.getContext().getAuthentication().getName();
    // 从cookie中读取购物车数据
    String cookieValue = util.CookieUtil.getCookieValue(request, "cartList", "UTF-8");
    if (cookieValue == null || "".equals(cookieValue)) cookieValue = "[]";
    List<Cart> cartList_cookie = JSON.parseArray(cookieValue, Cart.class);

    if (username.equals("anonymousUser")) {		// 如果未登录	从cookie中读取
        // System.out.println("从cookie中读取");
        return cartList_cookie;
    }else {		// 用户已登录	从redis中读取
        List<Cart> cartList_redis = cartService.findCartListFromRedis(username);
        if (cartList_cookie.size()>0) {		// 本地购物车未合并
            // System.out.println("合并本地和redis购物车数据");
            // 合并本地和redis购物车数据
            cartList_redis = cartService.mergeCartList(cartList_cookie, cartList_redis);
            // 在存储到redis中
            cartService.addCartListToRedis( username, cartList_redis);
            // 清空本地缓存购物车
            util.CookieUtil.deleteCookie(request, response, "cartList");
        }
        return cartList_redis;
    }

}
```



**合并购物车**

当用户登录时，需要将存储在cookie中的购物车数据添加到redis服务器中。同时清空本地cookie中的数据。已达到合并的效果。

```java
@Override
public List<Cart> mergeCartList(List<Cart> cartList1, List<Cart> cartList2) {
    if(cartList1==null && cartList2 == null) return new ArrayList<Cart>();
    for(Cart cart : cartList2) {
        for(TbOrderItem orderItem : cart.getOrderItemList()) {
            cartList1 = addGoodsToCartList(cartList1, orderItem.getItemId(), orderItem.getNum());
        }
    }
    return cartList1;
}
```

循环一个 cartList 中的 orderItem 数据，然后逐个添加到另一个 cartList 中。然后控制层在 findCartList 中调用，因为用户登录之后，进入购物车页面时必定经过查询购物车数据的方法。在前面的控制层实现中已经给出代码实现。



*跳板页的思想*

用户添加购物车完成之后，如果需要购买那么必须先完成登录。该系统使用cas实现的单点登录。如果我们通过直接跳转到 `http://localhost:9100/cas/login` cas服务器地址来完成登录，这样会出现登录完成之后页面会跳转到cas服务器的登录成功的提示页面，而不是我们想要的购物车页面。

我们可以采用一种跳板页的方法来实现。点击登录然后跳转到跳板页 login.html。但是由于当前状态为未登录，该页面会被Spring Security拦截然后重定向到cas服务器的登录页，登录成功后会重新回到 login.html 页面。然后在 login.html 页面中执行 js 回跳到购物车页面即可。

```html
<!-- login.html中添加跳转页面 -->
<script type="text/javascript">
	location.href="cart.html";
</script>
```



### 跨域解决方案与提交订单

**JS  跨域请求**

通过 js 在不同的域之间进行数据传输或通信，比如用 ajax 向一个不同的域请求数据，或者通过 js 获取页面中不同域的框架中(iframe)的数据。只要**协议、域名、端口**有任何一个不同，都被当作是不同的域。这也是面试中经常会问到的一个问题。

商品详情页面点击提交订单，就会异步调用购物车模块的添加商品到购物车的逻辑。该过程就会用到跨域操作。如果不考虑跨域问题会出现如下问题。点击添加购物车没有响应。![跨域存在的问题](https://hexoblog-1253306922.cos.ap-guangzhou.myqcloud.com/photo2018/%E5%93%81%E4%BC%98%E8%B4%AD/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98.png)



  **跨域解决方案 CORS**

CORS 是一个 W3C 标准，全称是"跨域资源共享"（Cross-origin resource sharing）。CORS 需要浏览器和服务器同时支持。除了 IE10 以前的浏览器之外其它浏览器都支持。（IE并未实现W3C标准）

CORS 可以解决跨越问题，允许浏览器向跨源服务器发出 XMLHttpRequest 请求。当存在跨域请求时，浏览器会自动添加附加的头信息，有时候会多一次附加请求，但是用户不会察觉。实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。

请求过程：首先浏览器向服务器发送一个预请求，服务器返回一个 Preflight Response，如果服务器同意跨域请求，那么浏览器才能继续发送跨域请求。

```java
// 服务器只需要配置 response 响应头信息即可
response.setHeader("Access-Control-Allow-Origin", "http://localhost:9105");	// 允许跨域请求
response.setHeader("Access-Control-Allow-Credentials", "true");				// 允许携带cookie （方法中如果会操作cookie的话，必须添加该配置）
```

`Access-Control-Allow-Origin` 的配置表示服务器支持跨域请求的地址。此时也就是允许 `http://localhost:9105` 该地址的跨域请求。

另外 Spring 4.2 版本之后支持注解式跨域请求`@CrossOrigin(origins="http://localhost:9105",allowCredentials="true")	// spring 4.2版本以上支持注解的方式，allowCredentials="true"可以缺省`

CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定 Access-Control-Allow-Credentials 字段。另一方面，**开发者必须在 AJAX 请求中打开 withCredentials 属性**。否则，即使服务器同意发送 Cookie，浏览器也不会发送（点击添加购物车，登录之后，cookie中的购物车数据不会合并到用户的购物车中）。或者，服务器要求设置 Cookie，浏览器也不会处理。

```javascript
 // 添加到购物车
 $scope.addToCart=function(){
	 // alert('sku_id:'+ $scope.sku.id);
	 // 执行跨域请求
	 $http.get("http://localhost:9107/cart/addGoodsToCartList.do?itemId="+ $scope.sku.id +"&num=" 
			 + $scope.num, {'withCredentials':true}).success(
			 function(response){
				 if (response.success) {
					location.href="http://localhost:9107/cart.html";	// 跳转到购物车页面
				}else{
					alert(response.message);
				}
			 }
	 );
 }
```



**结算页信息显示**

*收件人的的选择*

点击购物车进入结算页，首先会让用户选择收货地址以及收货人信息。而收获人信息是个用户进行关联的，所以将该模块放置在user模块中，在 AddressService 中新增一个通过用户ID查询收货人的信息的方法。然后在controller层，通过SpringSecurityu获取当前登录用户的ID，然后通过服务方法从数据库中取出用户的收获信息列表。前端以列表的信息显示出来。

```javascript
// 查询用户的收货地址信息
$scope.findAddress=function(){
    cartService.findAddress().success(
            function(response){
                $scope.addressList = response;
                // 查找默认地址
                for(var i=0;i<$scope.addressList.length;i++){
                    if($scope.addressList[i].isDefault=='1'){
                        $scope.address=$scope.addressList[i];break;
                    }
                }
            }
    );
}

// 选择地址
$scope.selectAddress=function(address){
    $scope.address = address;
}

// 该地址是否被选
$scope.isSelectedAddress=function(address){
    return ($scope.address == address);
}
```



*支付方式*

通过 `$scope.order={paymentType:'1'}; `中的paymentType字段来绑定页面的支付方式，1表示微信支付，2表示货到付款 。



*商品清单与金额显示*

cartController.js 中之前实现了获取购物车的信息。此处的商品清单也可以通过该方法，从redis中获取用户购买的信息。然后通过 ng-repeat 循环遍历显示即可。合计金额也可以通过 sum 方法计算求和。



  **分布式 ID  生成器**

snowflake 算法。由 Twitter 推出的一款开源的**分布式自增ID**生成算法。

结构：

0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000

第一位为未使用，接下来的41位为毫秒级时间(41位的长度可以使用69年)，然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点），最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）

一共加起来刚好64位，为一个Long型。(转换成字符串后长度最多19)

snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分不同机器之间也就不会出现重复ID的情况），并且效率较高。经测试snowflake每秒能够产生26万个ID。

*注：UUID 存在的问题：128位（16字节）较占内存，无法生成有序的ID。*

IdWorker 生成器工具类位于 common 工程。创建一个 IdWorker 对象，然后调用 nextId() 即可生成一个全局唯一ID。在Spring工程中，我们可以通过配置的方式来构造bean。

```xml
<bean id="idWorker" class="util.IdWorker">
    <!-- 进程 ID -->
    <constructor-arg index="0" value="0"></constructor-arg>
    <!-- 数据中心 ID -->
    <constructor-arg index="1" value="0"></constructor-arg>
</bean>
```



**保存订单**

取出 redis 中存储的用户购物车数据，生成对应的订单项，采用 snowflake 算法生成唯一的订单ID，然后根据商品的SKU信息生成多个订单项。



### 微信二维码支付模块



**二维码生成插件 qrious**
	qrious 是一款基于 HTML5 Canvas 的纯 JS 二维码生成插件。通过 qrious.js 可以快速生成各种二维码，你可以控制二维码的尺寸颜色，还可以将生成的二维码进行 Base64 编码。

配置参数：![qrious配置参数](https://hexoblog-1253306922.cos.ap-guangzhou.myqcloud.com/photo2018/%E5%93%81%E4%BC%98%E8%B4%AD/qriousc%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE.png)



**微信扫码支付**

商户系统按微信支付协议生成支付二维码，用户再用微信“扫一扫”完成支付的模式。该模式适用于 PC 网站支付、实体店单品或订单支付、媒体广告支付等场景。

具体开发文档：https://pay.weixin.qq.com/wiki/doc/api/index.html 主要了解Native支付的统一下单和查询订单API。

实现原理：首先引入微信支付的sdk依赖。使用 **HttpClient 工具类**，来模拟浏览器行为，去调用微信支付的 api 接口，向该地址提交相应的数据，然后获取结果。

由于使用微信扫码支付的申请条件比较苛刻，所以这一模块无法完成测试。提供的公共号、商户号、秘钥信息等，无法完成签名。返回的信息为签名错误。



*服务接口层*

pay-interface 

*服务实现层*

pay-service 依赖 pay 接口，和common模块（将 httpclient 工具类放在公共层、以及微信支付的基本信息配置），spring dubbo 依赖以及微信的 SDK。实现生成二维码和查询订单状态的方法。

*控制层*

cart-web 模块依赖支付服务，生成订单之后进入支付页面，调用服务层的生成二维码的方法，得到返回的 code_url ，然后让前端 qrious 插件根据该 url 去生成二维码即可。然后后端定时调用查询订单状态的方法，每隔3秒钟去查询订单支付状态，同时每隔五分钟之后就提示二维码支付超时，然后前端就收到超时信息之后，可以将其显示出来或者重新生成二维码信息。同时如果前端页面被关闭，后端会在五分钟之后返回超时的提示。



**支付日志**

 （1）在用户下订单时，判断如果为微信支付，就向支付日志表添加一条记录，信息包括支付总金额、订单 ID（一个支付日志对应多个订单）、用户 ID 、下单时间等信息，支付状态为 0（未支付）
	（2）生成的支付日志对象放入 redis 中，以用户 ID 作为 key，这样在生成支付二维码时就可以从 redis 中提取支付日志对象中的金额和订单号。
	（3）当用户支付成功后，修改支付日志的支付状态为 1（已支付），并记录微信传递给我们的交易流水号。根据订单 ID（多个）修改订单的状态为 2（已付款）。同时删除缓存中的支付日志。



### 秒杀解决方案

秒杀的特点就是在特定的时间对限量的商品进行抢购。在该时间可能存在很高的并发请求，而造成对后端数据库的巨大压力。此时可以采用缓存机制，来避免用户直接与数据库的交互。*秒杀时说有数据都存储在缓存中，只有当商品抢购完或者时间到期时才将缓存中的数据一次性存入数据库中。*

模块需求：

（1）商家提交秒杀商品申请，录入秒杀商品数据，主要包括：商品标题、原价、秒杀价、商品图片、介绍等信息

（2）运营商审核秒杀申请

（3）秒杀频道首页列出正在秒杀的商品，用户点击秒杀商品图片跳转到秒杀商品详细页。

（4）商品详细页显示秒杀商品信息，点击立即抢购实现秒杀下单，下单时扣减库存。当库存为 0 或不在活动期范围内时无法秒杀。

（5）秒杀下单成功，直接跳转到支付页面（微信扫码），支付成功，跳转到成功页，填写收货地址、电话、收件人等信息，完成订单。

（6）当用户秒杀下单 5 分钟内未支付，取消预订单，调用微信支付的关闭订单接口，恢复库存。



**秒杀频道首页**

seckill 模块服务层

```java
/**
 * 返回当前正在参与秒杀的商品
 */
@Override
public List<TbSeckillGoods> findList() {
    List<TbSeckillGoods> seckillGoodsList = redisTemplate.boundHashOps("seckillGoods").values();

    if (seckillGoodsList==null || seckillGoodsList.size()==0) {	 // 当前缓存还没有数据
        TbSeckillGoodsExample example = new TbSeckillGoodsExample();
        Criteria criteria = example.createCriteria();
        criteria.andStatusEqualTo("1");						// 已审核状态
        criteria.andStockCountGreaterThan(0);				// 库存量>0
        criteria.andStartTimeLessThanOrEqualTo(new Date());	// 当前时间大于等于开始时间
        criteria.andEndTimeGreaterThanOrEqualTo(new Date());// 当前时间晚于结束时间
        seckillGoodsList = seckillGoodsMapper.selectByExample(example );	// 从数据库中读取数据

        for(TbSeckillGoods seckillGood : seckillGoodsList) {	// 将当前时间的秒杀商品按商品ID存入缓存
            redisTemplate.boundHashOps("seckillGoods").put(seckillGood.getId(), seckillGood);
        }
        System.out.println("从数据库中读取秒杀商品并放入缓存");
    }else {
        System.out.println("从缓存中读取秒杀商品数据");
    }

    return seckillGoodsList;
}

@Override
public TbSeckillGoods findOneFromRedis(Long id) {
    return (TbSeckillGoods) redisTemplate.boundHashOps("seckillGoods").get(id);
}
```



控制层

```java
/**
 * 从数据库中查询当前秒杀的商品
 * @return
 */
@RequestMapping("/findList")
public List<TbSeckillGoods> findList() {
    return seckillGoodsService.findList();
}

@RequestMapping("/findOneFromRedis")
public TbSeckillGoods findOneFromRedis(Long id) {
    return seckillGoodsService.findOneFromRedis(id);
}
```



前端服务层

```javascript
app.service('seckillGoodsService',function($http){
	
	//读取列表数据绑定到表单中
	this.findList=function(){
		return $http.get('seckillGoods/findList.do');
	}
	
	this.findOne=function(id){
		return $http.get('seckillGoods/findOneFromRedis.do?id='+id); 
	}
	
	this.submitOrder=function(seckillId){
		return $http.get('seckillOrder/submitOrder.do?seckillId='+seckillId);
	}
});
```



前端控制层

```javascript
app.controller('seckillGoodsController', function($scope, $location, $interval, seckillGoodsService){ 
	
	// 读取列表数据绑定到表单中
	$scope.findList=function(){
		seckillGoodsService.findList().success(
			function(response){
				$scope.list=response;
			} 
		);
	}
	
	//查询实体	点击秒杀首页商品的详情页时，跳转到详情页，传递商品的ID信息
	$scope.findOne=function(){ 
		seckillGoodsService.findOne($location.search()['id']).success(
			function(response){
				$scope.entity = response;
				totalSecond = Math.floor((new Date($scope.entity.endTime).getTime() - (new Date().getTime()))/1000);
				time = $interval(function(){	// 倒计时的实现
					if (totalSecond>0) {
						$scope.timeString = convertSecondToTime(totalSecond);
						--totalSecond;
					}else{
						alert("秒杀已结束");
						$interval.cancel(time);
					}
				}, 1000);
			}
		);
	}
	
	convertSecondToTime=function(totalSecond){
		var sec = totalSecond%60;
		totalSecond = Math.floor(totalSecond/60);
		var min = totalSecond%60;
		totalSecond = Math.floor(totalSecond/60);
		var hour = totalSecond%24;
		totalSecond = Math.floor(totalSecond/24);
		var day = totalSecond;
		return day==0? hour+":"+min+":"+sec : day+"天 "+hour+":"+min+":"+sec;
	}
	
	$scope.submitOrder=function(){
		seckillGoodsService.submitOrder($scope.entity.id).success(
				function(response){
					if (response.success) {
						alert("抢购成功，请在五分钟内付款");
						location.href="pay.html";
					}else{
						alert(response.message);
					}
				}
		);
	}
	
});
```



**秒杀倒计时效果**

$interval 服务用来间歇性处理某事务

格式：$interval(执行的函数,间隔的毫秒数,运行次数);

```javascript
time = $interval(function(){	// 倒计时的实现
    if (totalSecond>0) {
        $scope.timeString = convertSecondToTime(totalSecond);// 格式转换
        --totalSecond;
    }else{
        alert("秒杀已结束");
        $interval.cancel(time);	 // 退出定时任务
    }
}, 1000);
```



**秒杀提交订单**

服务层逻辑

```java
@Override
public void submitOrder(Long seckillId, String userId) {
    // 从缓存中查询商品
    TbSeckillGoods seckillGoods = (TbSeckillGoods) redisTemplate.boundHashOps("seckillGoods").get(seckillId);
    // 判断商品状态
    if (seckillGoods == null) {
        throw new RuntimeException("商品不存在");
    }else if(seckillGoods.getStockCount()<=0){
        throw new RuntimeException("商品已抢购一空");
    }
    // 商品库存 -1
    seckillGoods.setStockCount(seckillGoods.getStockCount()-1);

    if (seckillGoods.getStockCount() == 0) {		// 商品被抢空
        redisTemplate.boundHashOps("seckillGoods").delete(seckillId);	// 删除缓存中该商品
        seckillGoodsMapper.updateByPrimaryKey(seckillGoods);			// 同步到数据库 
    }else {
        // 更新秒杀商品中数据
        redisTemplate.boundHashOps("seckillGoods").put(seckillId, seckillGoods);
    }

    // 生成订单信息
    TbSeckillOrder order = new TbSeckillOrder();
    order.setId(idWorker.nextId());					// 生成订单ID
    order.setSeckillId(seckillId);					// 秒杀商品ID
    order.setMoney(seckillGoods.getCostPrice());	// 秒杀价格
    order.setUserId(userId);
    order.setSellerId(seckillGoods.getSellerId()); 	// 商家ID
    order.setCreateTime(new Date());
    order.setStatus("0"); 							// 状态
    redisTemplate.boundHashOps("seckillOrder").put(userId, order);
}
```

控制层

```java
@RequestMapping("/submitOrder")
public Result submitOrder(Long seckillId) {
    String username = SecurityContextHolder.getContext().getAuthentication().getName();
    if ("anonymousUser".equals(username)) { // 如果未登录
        return new Result(false, "用户未登录");
    }

    try {
        seckillOrderService.submitOrder(seckillId, username);
        return new Result(true, "订单提交成功");
    } catch (RuntimeException e) {
        e.printStackTrace();
        return new Result(false, e.getMessage());
    } catch (Exception e) {
        e.printStackTrace();
        return new Result(false, "订单提交失败");
    }
}
```



**秒杀支付**

用户抢购成功之后跳转到支付页面。调用微信二维码支付接口，生成二维码，用户支付完成之后跳转到收获人地址信息填写页面。超过五分钟未付款就取消订单，恢复redis中的库存量，同时关闭微信订单，防止用户支付无效的订单。由于微信支付接口无法测试该功能预留。